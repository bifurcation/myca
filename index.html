<!DOCTYPE html5>
<html>

<head>
<title>MyCA - DIY HTTPS Certificates</title>
<script src="./jquery-2.1.4.min.js"></script>
<script src="./forge.min.js"></script>
<script src="./FileSaver.min.js"></script>
<script src="./index.js"></script>
</head>

<body>

<h1>MyCA &mdash; DIY HTTPS Certificates</h1>

<p>
- intro
- https good
- CAs less good
- make a root, then make server certificates
- set up SSL with the config generator
</p>


<h2>Act I: Make a root certificate</h2>

<!--
XXX: Unconstrained roots are bad

It doesn't thrill me that this design pattern encourages the creation
of omnipotent roots, at a time when we want the CAs to be constrained.
It would be better if we could create roots that have name constraints
that restrict them to the issued certificates, or to some zone.  But
JS crypto support for name constraints isn't really there right now,
so I'm omitting it for now in the name of a minimum viable product.
-->

<ol>
<li>Name this root: <input type="text" id="rootName"/></li>
<li><button id="makeRoot">Sign the root certificate</button><span id="makeRootStatus"></span></li>
<li>Download the <span id="downloadRootKey">key</span> and <span id="downloadRootCert">certificate</span></li>
</ol>

<h3>Quick check</h3>

<pre>
> openssl x509 -in root.cert.pem -text
> openssl verify -CAfile root.cert.pem root.cert.pem
</pre>


<h2>Act II: Make server certificate(s)</h2>

<p>
- you need to have a root certificate before you do this step
</p>

<ol>
<li>Load your root:
  <ul>
  <li>Select key file: <input type="file" id="rootKey"><span id="rootKeyStatus"></span></li>
  <li>Select certificate file: <input type="file" id="rootCert"><span id="rootCertStatus"></span></li>
  </ul>
</li>
<li>Enter names (whitespace-separated):<br/>
    <textarea id="serverNames" rows="5" cols="50"></textarea><br/>
    <span id="serverNamesStatus"></span>
</li>
<li><button id="makeServer">Sign the server certificate</button><span id="makeServerStatus"></span></li>
<li>Download the <span id="downloadServerKey">key</span> and <span id="downloadServerCert">certificate</span></li>
</ol>

<h3>Quick check</h3>

<pre>
> openssl x509 -in server.cert.pem -text
> openssl verify -CAfile root.cert.pem server.cert.pem
</pre>


<h2>Act III: Install the certificates</h2>

<p>You should have the following things now: a root key, a root certificate, a server key and a server certificate.  Each of these needs to be used a little differently.
</p>

<ul>
<li><b>Root key (root.key.pem):</b> This one is easy.  Just save this somewhere in case you want to make more server certificates later.</li>
<li><b>Root certificate (root.cert.pem):</b> This certificate will need to be installed as a trusted authority in every browser that you want to be able to connect to your sites.  How to do that will depend on the browser (<a href="TODO">IE</a> <a href="TODO">Cr</a> <a href="TODO">Fx</a> <a href="TODO">Sa</a>)</li>
<li><b>Server key (server.key.pem) and server certificate (server.key.pem):</b> How you install the server key certificate is going to depend on your server setup, or your hosting provider if you're not running your own server.  If you're running your own server, the <a href="TODO">Mozilla config generator</a> can help you get set up.  If you're in a hosted environment, please see your hosting provider's documentation.</li>
</ul>


<h3>Quick check</h3>

<pre>
&gt; openssl s_server -accept 8080 -www -key server.key.pem -cert server.cert.pem
&gt; openssl s_client -connect localhost:8080 -CAfile root.cert.pem 2&gt;/dev/null &lt;/dev/null | grep "Verify return code"
</pre>


<h2>Caveats!</h2>

<p>Through the magic of JavaScript, this is all done on your computer.  MyCA never sees your private information, and will not be able to impersonate your servers.</p>

<p>[[ It really is better to have a real certificate.  It saves the work of having to reconfigure every browser you want to connect (or click through warnings). CertBuddy, StartSSL, WoSign, etc. ]]</p>


</body>

</html>
